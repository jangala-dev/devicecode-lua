local op = require "fibers.op"
local context = require "fibers.context"
local sleep = require "fibers.sleep"
local service = require "service"
local log = require "log"
local new_msg = require "bus".new_msg
local apn = require "services.gsm.apn"

local gsm_service = {
    name = 'GSM'
}
gsm_service.__index = {}

-- for now we only hold configs about modems but later may need to hold
-- sim and sim switching configs as well
local configs = {
    modem = {
        default = {},
        imei = {},
        device = {}
    }
}

-- store active modems by preffered id field, imei by default
local modems = {
    imei = {},
    device = {},
}

local Modem = {}
Modem.__index = Modem

-- this function is not used and needs to be discussed about relevance for bb0.9
-- function Modem:autounlock_sim(ctx)
--     local pin_unlock_attempts_sub = self.bus_conn:subscribe(
--         { 'hal', 'capability', 'modem', self.idx, 'info', 'modem', 'generic', 'unlock-retries' }
--     )
--     local pin_unlock_attempts, pin_unlock_attempts_err = pin_unlock_attempts_sub:next_msg_with_context_op(ctx)
--         :perform_alt(function()
--             return nil, 'pin unlock attempts not found'
--         end)
--     if pin_unlock_attempts_err then return nil, pin_unlock_attempts_err end
--     for _, attempts in ipairs(pin_unlock_attempts) do
--         local unlock_attempts = attempts:match("^sim%-pin %((%d+)%)$")
--         if unlock_attempts and tonumber(unlock_attempts) <= 1 then
--             return nil, 'cannot try unlocking SIM cards with only one attempt left'
--         end
--     end

--     local iccid_sub = self.bus_conn:subscribe(
--         { 'hal', 'capability', 'modem', self.idx, 'info', 'sim', 'properties', 'iccid' }
--     )
--     local iccid, iccid_err = iccid_sub:next_msg_with_context_op(ctx)
--     if iccid_err then return nil, iccid_err end

--     local pin, pin_err = "todo -- is pin generated by another service?", iccid
--     if pin_err then return nil, pin_err end

--     local _, unlock_err = self.modem_capability:unlock(pin)
--     if unlock_err then return nil, unlock_err end
--     return "successfully unlocked", nil
-- end

-- Autoconnect function attempts to connect the modem to the network using APNs
function Modem:autoconnect(ctx, cutoff)
    cutoff = cutoff or 4

    -- Subscribe to various modem information topics on the bus
    local mcc_sub = self.bus_conn:subscribe(
        { 'hal', 'capability', 'modem', self.idx, 'info', 'nas', 'home-network', 'mcc' }
    )
    local mcc_msg, mcc_err = mcc_sub:next_msg_with_context_op(ctx):perform()
    mcc_sub:unsubscribe()

    if mcc_err then return nil, mcc_err end
    local mcc = mcc_msg.payload

    local mnc_sub = self.bus_conn:subscribe(
        { 'hal', 'capability', 'modem', self.idx, 'info', 'nas', 'home-network', 'mnc' }
    )
    local mnc_msg, mnc_err = mnc_sub:next_msg_with_context_op(ctx):perform()
    mnc_sub:unsubscribe()
    if mnc_err then return nil, mnc_err end
    local mnc = mnc_msg.payload

    local imsi_sub = self.bus_conn:subscribe(
        { 'hal', 'capability', 'modem', self.idx, 'info', 'sim', 'properties', 'imsi' }
    )
    local imsi_msg, imsi_err = imsi_sub:next_msg_with_context_op(ctx):perform()
    imsi_sub:unsubscribe()
    if imsi_err then return nil, imsi_err end
    local imsi = imsi_msg.payload

    -- local spn, spn_err = self.modem_capability:get_spn() -- this is needed for giffgaff but for now im not doing it because I don't want to
    local spn = nil

    local gid1_sub = self.bus_conn:subscribe(
        { 'hal', 'capability', 'modem', self.idx, 'info', 'gids', 'gid1' }
    )
    local gid1_msg, gid1_err = gid1_sub:next_msg_with_context_op(ctx):perform()
    gid1_sub:unsubscribe()
    if gid1_err then return nil, gid1_err end
    local gid1 = gid1_msg.payload

    -- todo: how to feed apns from configs into this fiber?
    -- (this fiber cannot directly access memory from the gsm_manager)

    local status_sub = self.bus_conn:subscribe(
        { 'hal', 'capability', 'modem', self.idx, 'info', 'state' }
    )

    -- get apns by rank and iterate through all apns within rank requirements
    -- attempt connection on each apn
    local apns, ranks = apn.get_ranked_apns(mcc, mnc, imsi, spn, gid1)
    for _, n in ipairs(ranks) do
        if n.rank > cutoff then break end
        local apn_connect_string, string_err = apn.build_connection_string(apns[n.name], self.cfg.roaming_allow)
        if string_err == nil then
            local connect_sub = self.bus_conn:request(new_msg(
                { 'hal', 'capability', 'modem', self.idx, 'control', 'connect' },
                { apn_connect_string }
            ))
            local connect_msg, ctx_err = connect_sub:next_msg_with_context_op(ctx):perform()
            if ctx_err then
                log.trace(ctx_err); return
            end
            local connect_err = connect_msg.payload.err
            if connect_err == nil then
                return apns[n.name], nil
            else
                if string.find(connect_msg.payload.result, "pdn-ipv4-call-throttled") then
                    return nil, "pdn-ipv4-call-throttled"
                end
            end

            -- need to wait for current connection attempt to finish before trying another
            local modem_status = 'connecting'
            while modem_status == 'connecting' do
                local status_msg, status_err = status_sub:next_msg_with_context_op(ctx):perform()
                if status_err then
                    log.trace(status_err); return
                end
                modem_status = status_msg.payload.curr_state
            end
        end
    end
    status_sub:unsubscribe()
    return nil, "no apn connected"
end

-- state machine to get modem into registered state ready for connection
function Modem:enable_autoconnect(ctx)
    service.spawn_fiber(
        'autoconnect - ' .. self.idx,
        self.bus_conn,
        ctx,
        function(autoconnect_ctx)
            log.info(string.format("GSM: Autoconnect started for %s", self.name))
            local connected = false
            local state_monitor_sub = self.bus_conn:subscribe({ 'hal', 'capability', 'modem', self.idx, 'info', 'state' })

            while not autoconnect_ctx:err() do
                -- listen for modem state changes
                local state_info_msg, monitor_err = state_monitor_sub:next_msg_with_context_op(autoconnect_ctx):perform()
                if monitor_err then
                    log.debug(monitor_err)
                    return
                end
                local state_info = state_info_msg.payload
                log.info(string.format("GSM: Autoconnect state for %s: %s", self.name, state_info.curr_state))
                -- locked state is currently unimplemented due to uncertainty of parity against dcv0.9
                if state_info.curr_state == 'locked' then
                    -- local _, unlock_err = self:autounlock_sim(autoconnect_ctx) -- will implement this later
                    local unlock_err = 'not implemented'
                    if unlock_err then log.error('GSM_SIM_UNLOCK_FAILED', self.name, unlock_err) end
                elseif state_info.curr_state == 'failed' then
                    -- hal has a simple endpoint to get modem out of failure state
                    local fix_failure_sub = self.bus_conn:request(new_msg(
                        { 'hal', 'capability', 'modem', self.idx, 'control', 'fix_failure' },
                        {}
                    ))
                    -- this will return a successful dispatch of a fix_failure command, but not if the failure has actually
                    -- been fixed, for that we must listen to the state change
                    local ret_msg, ctx_err = fix_failure_sub:next_msg_with_context_op(autoconnect_ctx):perform()
                    if ctx_err then
                        log.trace(ctx_err); return
                    end

                    local fix_err = ret_msg.payload.err
                    if fix_err then log.error("GSM_MODEM_FAILURE_FIX_FAILED", self.name, fix_err) end
                -- no_sim is currently untestable due to modem disconnection issue
                elseif state_info.curr_state == 'no_sim' then
                    -- same as fix_failure for sim_detect except implementation is much faster and simpler
                    local sim_detect_sub = self.bus_conn:request(new_msg(
                        { 'hal', 'capability', 'modem', self.idx, 'control', 'sim_detect' },
                        {}
                    ))

                    -- check for successful dispatch of detect command
                    local ret_msg, ctx_err = sim_detect_sub:next_msg_with_context_op(autoconnect_ctx):perform()
                    if ctx_err then
                        log.trace(ctx_err); return
                    end
                    local sim_err = ret_msg.payload.err
                    if sim_err then log.error("GSM_MODEM_NO_SIM_WAIT_FAIL", self.name, sim_err) end
                elseif state_info.curr_state == 'disabled' then
                    -- simple state, if mode is disabled then enable
                    local enable_sub = self.bus_conn:request(new_msg(
                        { 'hal', 'capability', 'modem', self.idx, 'control', 'enable' },
                        {}
                    ))
                    local ret_msg, ctx_err = enable_sub:next_msg_with_context_op(autoconnect_ctx):perform()
                    if ctx_err then
                        log.trace(ctx_err); return
                    end
                    local enable_err = ret_msg.payload.err
                    if enable_err then log.error("GSM_MODEM_ENABLE_FAILED", self.name, enable_err) end
                elseif state_info.curr_state == 'registered' then
                    -- get details needed for net service to connect modem to internet or whatever
                    -- QUESTION: should we be sending the apn to net? what is it needed for?
                    local active_apn, autoconnect_err = self:autoconnect(autoconnect_ctx)
                    if autoconnect_err then
                        log.error("GSM_MODEM_CONNECT_FAILED", self.name, autoconnect_err)
                        -- if the modem has throttled too many connection requests have been made, so delay for 6 minutes
                        -- this may be deleted as it seems to be a 5g modem only issue
                        local retry_delay = (autoconnect_err == "pdn-ipv4-call-throttled") and 360 or 20
                        sleep.sleep(retry_delay)
                    else
                        log.info("GSM_MODEM_CONNECTED", self.name)
                        local signal_freq = self.cfg.signal_freq or 5
                        local result, signal_update_err = self.bus_conn:request(new_msg(
                            { 'hal', 'capability', 'modem', self.idx, 'control', 'set_signal_update_freq' },
                            { signal_freq }
                        )):next_msg_with_context_op(autoconnect_ctx):perform()
                        if signal_update_err then
                            log.warn("GSM_MODEM_SIGNAL_UPDATE_FAILED", self.name, signal_update_err)
                        end
                        self.cfg.apn = active_apn
                    end
                elseif state_info.curr_state == 'connected' then
                    local net_iface_sub = self.bus_conn:subscribe(
                        { 'hal', 'capability', 'modem', self.idx, 'info', 'modem', 'generic', 'ports', '+' }
                    )
                    -- the bus handles multiple publish for lists as having numbered endpoints
                    -- iterate over all numbered endpoints of ports and check which one holds the net iface; if any
                    -- only breaks if iface is found, otherwise errors out
                    local net_interface
                    while true do
                        local net_interface_msg, interface_err = net_iface_sub:next_msg_with_context_op(context
                            .with_timeout(self.ctx, 1)):perform()
                        if interface_err then
                            log.error("GSM_MODEM_NET_IFACE_ERROR", self.name, interface_err)
                            return
                        end
                        net_interface = net_interface_msg.payload:match("%s*(%S+)%s%(net%)")
                        if net_interface then
                            break
                        end
                    end

                    self.bus_conn:publish(new_msg(
                        { 'gsm', 'modem', self.name, 'interface' },
                        { net_interface },
                        { retained = true }
                    ))
                end

                local next_connected = state_info.curr_state == 'connected'
                if next_connected ~= connected then
                    self.bus_conn:publish(new_msg(
                        { 'gsm', 'modem', self.idx, 'connected' },
                        { connected = connected },
                        { retained = true }
                    ))
                end
            end
            state_monitor_sub:unsubscribe()
            log.trace(string.format("GSM: Autoconnect - %s Closing, reason: '%s'", self.name, autoconnect_ctx:err()))
        end
    )
    return true
end

function Modem:update_config(config)
    -- stop autoconnect if it is enabled and the new config is disabled
    if config.autoconnect == false and self.autoconnect_ctx and not self.autoconnect_ctx:err() then
        self.autoconnect_ctx:cancel()
        -- start autoconnect if it is disabled and the new config is enabled
    elseif config.autoconnect == true and (not self.autoconnect_ctx or self.autoconnect_ctx:err()) then
        self.autoconnect_ctx = context.with_cancel(self.ctx)
        self:enable_autoconnect(self.autoconnect_ctx)
    end
    self.cfg = config

    -- every modem is initialised with a name either from config or from the imei
    self.name = self.cfg.name or self.imei
end

local function new_modem(ctx, bus_conn, imei, index, modemcard)
    local self = setmetatable({}, Modem)
    self.ctx = context.with_cancel(ctx)
    self.bus_conn = bus_conn

    self.idx = index
    self.imei = imei
    self.modemcard = modemcard

    return self
end

-- Current bug is that the correct config is not being applied despite setting one for my modem of certain imei.
-- modem_config is nil when it should be the custom config
-- check how the config is saved and what the return of configs.modem.imei[imei] is
-- lines of interest 284, 328
local function modem_capability_handler(ctx, bus_conn, modem_capability_msg)
    if modem_capability_msg == nil then return end

    -- get imei and device (port) info from bus
    local modem_imei_sub = bus_conn:subscribe({ 'hal', 'capability', 'modem', modem_capability_msg.index, 'info',
        'modem', 'generic', 'equipment-identifier' })
    local imei_msg, imei_err = modem_imei_sub:next_msg_with_context_op(ctx):perform()
    modem_imei_sub:unsubscribe()
    if imei_err then
        log.error(imei_err); return
    end
    local imei = imei_msg.payload

    local modem_device_sub = bus_conn:subscribe({ 'hal', 'capability', 'modem', modem_capability_msg.index, 'info',
        'modem', 'generic', 'device' })
    local device_msg, device_err = modem_device_sub:next_msg_op():perform_alt(function()
        return nil, 'device not found'
    end)
    modem_device_sub:unsubscribe()
    if device_err then
        log.error(device_err); return
    end
    local device = device_msg.payload

    local modem_config = configs.modem.imei[imei] or configs.modem.device[device]
    local id_field, key
    if modem_config then
        id_field = modem_config.id_field
        key = modem_config[id_field]
    else
        -- default modems will be stored by imei
        id_field = 'imei'
        key = imei
        modem_config = configs.modem.default
    end

    if modem_capability_msg.connected then
        local modem = new_modem(ctx, bus_conn, imei, modem_capability_msg.index, modem_capability_msg.device)
        modem:update_config(modem_config)
        modems[id_field][key] = modem
        log.info(string.format('Modem Capability %s detected', modem_capability_msg.index))
    else
        if modems[id_field][key] then
            modems[id_field][key].ctx:cancel('modem disconnected')
            modems[id_field][key] = nil
            log.info(string.format('Modem Capability %s removed', modem_capability_msg.index))
        end
    end
end

-- merge custom config with default to avoid any missing fields
local function apply_defaults(config, defaults)
    for k, v in pairs(defaults) do
        if config[k] == nil then
            config[k] = v
        end
    end
end

-- resturetures configs and applies them if they match an active modem
local function config_handler(config_msg)
    log.trace("GSM received config")
    if config_msg and config_msg.payload then
        local modem_configs = config_msg.payload.modems
        local default_config = modem_configs.default
        configs.modem.default = default_config

        for name, known_config in pairs(modem_configs.known) do
            local id_field = known_config.id_field
            apply_defaults(known_config, default_config)
            known_config.name = name
            configs.modem[id_field][known_config[id_field]] = known_config

            if modems[id_field][known_config[id_field]] then
                modems[id_field][known_config[id_field]]:update_config(known_config)
            end
        end

        for _, modem in ipairs(modems.imei) do
            if not modem.cfg.name then
                modem:update_config(default_config)
            end
        end
    end
end

local function gsm_manager(ctx, bus_conn)
    local capability_sub = bus_conn:subscribe({ 'hal', 'capability', 'modem', '+' })
    local config_sub = bus_conn:subscribe({ 'config', 'gsm' })

    -- load config before anything else
    local config, config_err = config_sub:next_msg_with_context_op(ctx):perform()
    if config_err then
        log.trace(config_err)
        return
    end
    config_handler(config)

    while not ctx:err() do
        op.choice(
            capability_sub:next_msg_op():wrap(function(capability_msg)
                modem_capability_handler(ctx, bus_conn, capability_msg.payload)
            end
            ),
            config_sub:next_msg_op():wrap(config_handler),
            ctx:done_op()
        ):perform()
    end
    capability_sub:unsubscribe()
    config_sub:unsubscribe()
    log.trace(string.format("GSM: Manager Closing, reason: '%s'", ctx:err()))
end

function gsm_service:start(service_ctx, bus_connection)
    log.trace("Starting GSM Service")
    service.spawn_fiber('GSM fiber', bus_connection, service_ctx, function(fiber_ctx)
        gsm_manager(fiber_ctx, bus_connection)
    end)
end

return gsm_service
